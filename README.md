# 要解决的问题
1. k8s 是重量级的支持高可用，的容器部署方案
2. k8s 配置复杂，本项目是为了解决只有docker时，还可以轻松的部署容器
3. 不解决高可用的问题

## 痛点分析 
1. docker swarm
   1. 环境变量管理容易出错
   2. 端口管理直接暴露不安全，而且容易出错
   3. 不支持 特权模式
   4. 不支持有状态服务迁移
   5. 备份
2. docker compose
   1. 不能随意迁移，支持特权模式

## 解决思路
1. 环境变量管理的问题，提供一个树形kv管理界面。服务应用环境变量，与自身的k关联
   1. 镜像决定了具体一个变量在此环境中的名称
   2. 部署的运维决定了这个变量是什么，放在那个层级中
   3. 通过服务来绑定两者
2. 服务不直接暴露端口，而是通过反向代理对外暴露，http通过 domain name来区分服务
   1. 使用traefik来作为默认的反向代理
   2. 服务部署后接入traefik
3. 对于需要特权的服务采用compose模式直接部署
   1. 服务依赖于前置的状态检查逻辑，状态检查与hub服务通讯，来确保只有一个在运行
4. 启动服务前先确保有状态的系统的依赖文件已在本机克访问
   1. 对于迁移节点，
      1. 首先停止服务(swarm删除依赖标签/非swarm client停止)
      2. 移动文件到新的服务器
      3. 在新节点上启动服务
   2. 对于内存不足而软迁移(适合读写不频繁，占用cpu，内存高的):
      1. 通过nfs，允许服务部署到其他点上
      
## 工作流程
1. 将docker的控制sock挂载到服务中。启动服务
2. 服务创建traefik依赖
3. 服务启动web hub，获取到自己host
4. 将自己添加到traefik网络中
5. 并通过traefik暴露自己的管理界面
6. 服务创建部署client，并且确保client也挂载到了sock和数据卷。配置client 会掉地址位自己的host
7. client 启动成功，向hub发送注册请求，注册成功，并且定期更新数据
8. 用户在web中可以访问,hub 管理界面
9. 用户给node/机器添加 分组
10. 用户创建服务域，服务，通过分组/直接指定，来明确运行在哪
11. 产生变化清单
12. 用户出发部署，按照用户的部署结果执行

### 目录管理、
只读模式
1。 单个配置文件 （只读）
    1。 使用swarm时使用配置挂载
    1。 compose模式，吧配置复制到宿主机器上，本地挂载
1。 目录配置 （只读）
    1。 覆盖模式
        1。 compose/swarm 挂载目录
    1。 融合模式，先把镜像内的文件cp出来，在用修改的文件覆盖配置
可写模式  只有一个相同的instance

1。 备份与迁移 （可写目录只能有一个同镜像的 service同时允许），
    1。 swarm模式，通过标签来控制service运行位置。
    2。 compose模式，client来在宿主机器上启动，可以使用特权模式

